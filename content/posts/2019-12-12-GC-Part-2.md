---
title: Garbage Collector در CSharp - قسمت دوم
tags: ["CSharp", "C#", "GC", "Garbage Collector"]
date: "2019-12-12T23:00:00+03:30"
description: "در این سری مقالات قصد داریم وارد مبحث Memory Management در #C شده، با Garbage Collector آشنا و دیدی کلی از نحوه انجام کار آن داشته باشیم.
"
imageUrl: "/img/posts/2019-12-12-GC-Part-2/Heap.jpg"
weight: 1
---

در این مطلب قصد داریم به تفاوت‎های بین Stack و Heap در Memory و زبان #C بپردازیم.  
  
به زبان ساده، وقتی شما متغیر جدیدی ایجاد میکنید، با توجه به نوع (Type) آن متغیر، **"مقدار"** متغیر شما در Stack یا Heap قرار خواهد گرفت.  

----------

## Stack

Stack نوعی ساختمان داده است که در آن، داده‌ها بصورت خطی قرار گرفته و اصطلاحا ساختار  **LIFO** ( مخفف Last in, First Out ) دارند، بدین معنی که همیشه آخرین داده ای که داخل Stack قرار داده اید، اولین داده ای است که قادر به خواندن آن خواهید بود. وقتی در ساختار Stack داده ای را قرار میدهیم، اصطلاحا آن را  **Push** کرده و وقتی میخواهیم آخرین داده را با توجه به ساختار خطی آن بخوانیم، داده را  **Pop** میکنیم.

<br>
<img src="/img/posts/2019-12-12-GC-Part-2/Stack.png" height="450px" alt="Stack" style="margin:auto;">
<br>

این ساختمان داده داخل Memory پیاده سازی شده است و تعدادی از متغیرهایی که ما داخل کد ایجاد میکنیم، در این نوع ساختمان داده از Memory نگه داری میشوند.  
  
شرط قرار گرفتن مقدار یک متغیر داخل Stack این است که متغیر از نوع Value Type باشد. در زبان #C، بطور کلی Struct و Enum‌ها Value Type هستند و بصورت پیشفرض داخل Stack قرار میگیرند. تمامی ValueType‌ها در #C، بطور implicit از [System.ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype?view=netframework-4.8) ارث بری میکنند.  
  
Type‌های زیر، Value Type‌های پیشفرض تعریف شده در زبان #C هستند که به آن‌ها Simple Type نیز گفته میشوند: 

|   Type  |                          Represents                          |
|:-------:|:------------------------------------------------------------:|
|   bool  |                         Boolean value                        |
| integer |                    8-bit unsigned integer                    |
|   char  |                   16-bit Unicode character                   |
| decimal | 128-bit precise decimal values with 28-29 significant digits |
|  double |          64-bit double-precision floating point type         |
|  float  |          32-bit single-precision floating point type         |
|   int   |                  32-bit signed integer type                  |
|   long  |                  64-bit signed integer type                  |
|  sbyte  |                   8-bit signed integer type                  |
|  short  |                  16-bit signed integer type                  |
|   uint  |                 32-bit unsigned integer type                 |
|  ulong  |                 64-bit unsigned integer type                 |
|  ushort |                 16-bit unsigned integer type                 |

اگر سورس هرکدام از این تایپ‌ها مانند [Int32](https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/System/Int32.cs) را در ریپازیتوری CoreFX مایکروسافت بررسی کنید، متوجه خواهید شد که تمامی این تایپ‌ها از نوع Struct تعریف شده اند و همانطور که گفتیم، بطور پیشفرض Struct‌ها داخل Stack قرار خواهند گرفت.  
  
**طول عمر**  متغیرهایی که داخل Stack قرار گرفته اند، منحصر به پایان اجرای یک متد است. بدین معنی که بعد از به پایان رسیدن یک متد، تمامی متغیرهای مورد استفاده در آن متد، از حافظه Stack بطور خودکار حذف خواهند شد. متغیرهایی که داخل Stack قرار میگیرند، نوع و حجم مقادیرشان بر اساس Type ای دارند، در زمان Compile-Time مشخص است.  
  

متغیرهای محلی (Local Variable ها)، پارامترهای ورودی متد و مقدار بازگشتی یک متد، جز مواردی هستند که مقادیرشان داخل Stack قرار میگیرد:

```csharp
public static int Add(int number1, int number2)
{
    // number1 is on the stack (function parameter)
    // number2 is on the stack (function parameter)

    int sum = number1 + number2;
    // sum is on the stack (local variable)

    return sum;
}
```

<br>
در زبان #C و در مرحله Compile-Time، کدها به زبان IL (مخفف Intermediate Language) ترجمه میشوند که با نام‌های MSIL (مخفف Microsoft Intermediate Language ) و CIL (مخفف Common Intermediate Language ) نیز، این زبان شناخته میشود. ساختار این زبان Stack-based بوده و با شناخت آن، با مفهوم Stack نیز بهتر میتوانیم آشنا شویم.  
  
IL زبانی است که  _CLR_  (مخفف Common Language Runtime) که همان Runtime مایکروسافت است، شناخته و اجرا میکند. قابل ذکر است که Runtime مایکروسافت Open-Source بوده و سورس آن با نام  _CoreCLR_  در گذشته از [این آدرس](https://github.com/dotnet/coreclr) و در حال حاضر با نام  _Runtime_  از [این آدرس](https://github.com/dotnet/runtime) قابل دسترسی است.  
  

با استفاده از برنامه هایی مانند [dotPeek](https://www.jetbrains.com/decompiler) یا [dnSpy](https://github.com/0xd4d/dnSpy) یا [ILDASM](https://docs.microsoft.com/en-us/dotnet/framework/tools/ildasm-exe-il-disassembler) یا ابزار آنلاینی مانند [Sharplab](https://sharplab.io/) و ... میتوانید کدهای IL حاصل از dll‌های برنامه خود را ببینید. این ابزارها با یکدیگر تفاوت زیادی ندارند و تنها مزیت dnSpy به نسبت بقیه، قابلیت دیباگ کردن کدهای IL توسط آن میباشد و همچنین ILDASM با نصب Visual Studio، از این مسیر بدون نیاز به نصب برنامه اضافه ای قابل دسترسی است:

```csharp
C:\Program Files (x86)\Microsoft SDKs\Windows\{version}\Bin\ildasm.exe
```

<br>
همانطور که پیش‌تر گفتیم، طول عمر Stack محدود به پایان یک متد است. به این نوع Stack که هنگام صدا زدن یک متد ایجاد میشود و شامل ورودی‌های متد، متغیرهای محلی و آدرس خروجی هستند، Stack Frame یا Activation Frame گفته میشود.

<br>
<img src="/img/posts/2019-12-12-GC-Part-2/Stack-Structure.png" height="400px" alt="Stack Structure" style="margin:auto;">
<br>

اگر متد Add بالا را با پارامترهای 2 و 5 صدا بزنیم، خروجی IL حاصل از آن، که این دو عدد را بعنوان ورودی گرفته و جمع آنها را بعنوان خروجی میدهد، به این صورت خواهد بود ( قسمت هایی از خروجی جهت سادگی، حذف شده است) :

```csharp
.method private hidebysig static int32 Add(int32 number1, int32 number2) cil managed
{
  .locals init (int32 V_0, int32 V_1)

  IL_0001:  ldarg.0 // Stack is: [2]
  IL_0002:  ldarg.1 // Stack is: [2, 5]
  IL_0003:  add     // Stack is: [7]
  IL_0004:  stloc.0 // Stack is: [] and V_0's value is: 7

  IL_0005:  ldloc.0 // Stack is: [7]
  IL_0006:  stloc.1 // Stack is: [] and V_1's value is: 7

  IL_0009:  ldloc.1 // Stack is: [7]
  IL_000a:  ret     // Return [7]
}
```

  
میتوانید لیست دستورات مورد استفاده در CIL را [از اینجا](https://en.wikipedia.org/wiki/List_of_CIL_instructions) ببینید.  
  
در ادامه، خط به خط، خروجی حاصل را بررسی میکنیم:  

1- در زبان IL، میتوانید مقادیر حاصل از اعمال محاسباتی یا متدهای دیگر را داخل متغیرهای محلی ذخیره کنید، به شرط اینکه آنها را در ابتدا مشخص سازید.

&nbsp; &nbsp; • با استفاده از  **locals.**  که به معنای local variables است، میتوانید متغیرهای مورد نیازتان در طول عمر این متد را معرفی کنید. دادن نام برای این متغیرها [اجباری نیست](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.localvariableinfo?redirectedfrom=MSDN&view=netframework-4.8#remarks) (V_0 و V_1) و صرفا جهت خوانایی استفاده میشوند.  

  
2- از کلمه کلیدی  **ldarg** (مخفف Load Argument) برای لود کردن آرگومان یا همان پارامتر ورودی متد، داخل Stack استفاده میشود.  
&nbsp; &nbsp; • ldarg.0 به معنای لود کردن پارامتر ورودی اول، داخل Stack است و با فراخوانی آن، Stack Frame دارای یک عضو که مقدار آن 2 است، میشود.

&nbsp; &nbsp; • ldarg.1 به معنای لود کردن پارامتر ورودی دوم، داخل Stack است و با فراخوانی آن، Stack Frame دارای دو عضو که مقادیر آن 2 و 5 است، میشود.

  
3- با استفاده از کلمه کلیدی  **add**، مقادیر موجود در Stack با یکدیگر جمع میشوند و Stack Frame دارای یک عضو که مقدار آن 7 است، میشود.

  
4- با استفاده از کلمه کلیدی  **stloc** (مخفف Store Local)، آخرین عضو موجود در Stack، داخل متغیر محلی ذکر شده، قرار گرفته و ذخیره میشود.  

&nbsp; &nbsp; • stloc.0 به معنای ذخیره سازی آخرین مقدار موجود در Stack یعنی عدد 7، داخل متغیر 0 یعنی همان V_0 میباشد.

  
5- با استفاده از کلمه کلیدی  **ldloc** (مخفف Load Local)، میتوان متغیر محلی ذخیره شده را داخل Stack قرار داد.

&nbsp; &nbsp; • ldloc.0 به معنای Load کردن مقدار ذخیره شده متغیر محلی 0 که همان V_0 است، داخل Stack میباشد.  
  
6- در نهایت، مقدار 7، داخل متغیر 1 یا همان V_1 با دستور stloc.1 بار دیگر ذخیره، با ldloc.1 لود شده و با استفاده از دستور  **ret**، برگشت داده میشود.

**\* نکته:** اگر کدها را بطور دقیق بررسی کرده باشید، احتمالا فکر کرده اید که چه نیازی به ایجاد یک متغیر اضافی و ریختن نتیجه داخل آن و سپس برگشت دادن نتیجه، در مرحله 6 است؟!

در زبان #C، کدهای شما در زمان Release و همچنین JIT-Compilation، طی چندین مرحله Optimize میشوند و یکی از این مراحل، حذف این متغیرهای اضافی جهت Optimization و Performance است; پس از این بابت نگرانی وجود ندارد.  
  
**\* نکته:** احتمالا تا به اینجا دلیل بوجود آمدن  **StackOverflowException**  را متوجه شده باشید. فضای Stack محدود است. این فضا در سیستم‌های 32 بیت برابر با 1 مگابایت و در سیستم‌های 64 بیت برابر با 4 مگابایت است ([Reference](https://stackoverflow.com/a/28658130/6661314)). اگر حجم متغیرهایی که روی استک Push میشوند، این محدودیت را رد کنند و یا اگر یک متد بطور دائم خودش را صدا بزند (Recursive) و هیچگاه از آن خارج نشود، با خطای StackOverflowException مواجه میشوید.  

----------

## Heap

<br>
<img src="/img/posts/2019-12-12-GC-Part-2/Heap.jpg" height="450px" alt="Heap" style="margin:auto;">
<div style="text-align: center;">
	<span style="font-style: italic; text-color: gray;">.Heap: a group of things placed, thrown, or lying one on another</span>
</div>
<br>

در مقابل ساختار ترتیبی و منظم Stack، ساختار Heap قرار دارد. Heap قسمتی از حافظه هست که ساختار، ترتیب و Layout خاصی ندارد.

این نوع حافظه بر خلاف Stack، منحصر به یک متد نیست و اصطلاحا Global بوده و در هر قسمتی از برنامه قابل دسترسی است. تخصیص حافظه در این قسمت از حافظه اصطلاحا Dynamic بوده و هر نوع داده ای را در هر زمانی میتوان داخل آن ذخیره کرد.

  

string‌ها نمونه ای از typeهایی هستند که داخل Heap نگه داری میشوند. دقت کنید وقتی میگوییم نگه داری میشود، منظور "**مقدار**" یک متغیر است.  
  
وقتی یک متغیر از نوع string ایجاد میکنیم، مقدار آن داخل Heap و Memory-Address آن متغیر روی Heap، در Stack نگه داری میشود:

```csharp
public static void SayHi()
{
    string name = "Moien";
}
```

<br>
در این مثال، چون [string یک class است](https://github.com/dotnet/corefx/blob/master/src/Common/src/CoreLib/System/String.cs)، مقدار آن داخل heap ذخیره شده و آدرس آن قسمت (segment) از memory، روی Stack قرار میگیرد:

```csharp
.method private hidebysig static void SayHi() cil managed
{
  .locals init (string V_0)

  IL_0001:  ldstr      "Moien" // Stack is: [memory-address of string in heap]
  IL_0006:  stloc.0

  IL_0007:  ret
}
```

به متغیرهایی که مقادیرشان داخل Heap ذخیره میشوند، Reference-Type گفته میشود.  
  
**\* نکته:** در این مثال متغیری به نام name ایجاد شده که از آن هیچ استفاده ای نشده است. در زمان JIT-Compilation، با توجه با Optimization‌های موجود در سطح CLR، این متد بطور کلی اضافه تشخیص داده شده و از آن صرف نظر خواهد شد.  

<br>
<img src="/img/posts/2019-12-12-GC-Part-2/Heap.png" height="450px" alt="Heap Structure" style="margin:auto;">
<br>


----------

## Boxing and Unboxing

  
به فرایند تبدیل یک Value-Type مانند int که بصورت پیشفرض داخل Stack ذخیره میشود، به یک object که در داخل Heap ذخیره میشود،  **Boxing** گفته میشود. انجام این عمل باعث allocation روی memory میشود که سربار زیادی دارد.  
  
با انجام عمل Boxing، قادر خواهیم بود تا بعنوان مثال یک عدد را بر خلاف روال عادی آن، روی Heap ذخیره کنیم:

```csharp
public static void Boxing()
{
    const int number = 5;

    object boxedNumber = number;          // implicit boxing using implicit cast
    object boxedNumber = (object)number;  // explicit boxing using direct cast
}
```
<br>
در ابتدا عدد 5 روی Stack ذخیره شده بود، اما با Box کردن آن، یعنی قرار دادن مقدار آن داخل یک object، مقدار از Stack به Heap انتقال داده شده و allocation اتفاق خواهد افتاد:

```csharp
.method public hidebysig static void Boxing() cil managed
{
  .locals init (object V_0)

  IL_0001:  ldc.i4.5                                // Stack is: [5]
  IL_0002:  box        [System.Runtime]System.Int32 // Stack is: [memory-address of 5 in heap]

  IL_0007:  stloc.0
  IL_0008:  ret
}
```

<br>
به عکس این عمل، یعنی تبدیل یک Reference-Type به یک Value-Type، اصطلاحا  **Unboxing** گفته میشود:

```csharp
public static void Unboxing()
{
    object boxedNumber = 5;

    int number = (int)boxedNumber;
}
```

<br>
که نتیجه آن، به این صورت خواهد بود:

```csharp
.method public hidebysig static void Unboxing() cil managed
{
  .locals init (object V_0, int32 V_1)

  IL_0001:  ldc.i4.5                                  // Stack is: [5]
  IL_0002:  box        [System.Runtime]System.Int32   // Stack is: [memory-address of 5 in heap]
  IL_0007:  stloc.0                                   // Stack is: []

  IL_0008:  ldloc.0                                   // Stack is: [memory-address of 5 in heap]
  IL_0009:  unbox.any  [System.Runtime]System.Int32   // Stack is: [5]
  IL_000e:  stloc.1                                   // Stack is: []

  IL_000f:  ret
}
```

  
تلاش تیم‌های مایکروسافت طی سال‌های اخیر، باعث افزایش Performance فوق العاده در NET Core. و ASP.NET Core شده است. یکی از دلایل این Performance، جلوگیری بسیار زیاد از allocation در کدهای خود NET. است، که این امر به واسطه اولویت قرار دادن استفاده از Structها میسر گردیده است.

  
برخلاف Stack که طول عمر متغیرهای موجود در آن، در انتهای یک متد پایان میابند، متغیرهای allocate شده در Heap به این شکل نبوده و در صورت حذف نکردن آنها بصورت دستی، تا پایان طول عمر اجرای برنامه داخل memory باقی خواهند ماند. اینجا، جاییست که  **Garbage Collector**  در NET. وارد عمل میشود.